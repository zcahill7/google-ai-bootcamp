# -*- coding: utf-8 -*-
"""BigQuery table

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/embedded/projects/qwiklabs-gcp-03-d3c5d190e927/locations/us-central1/repositories/071e26ed-e412-41e7-aa0a-c48e00dbe806

# Challenge Two
# BigQuery ML: Predicting Emergency Call Response Times

# Step 1:
# Create Data set for Challenge Two
# Load data into table for Challenge Two
"""

# Commented out IPython magic to ensure Python compatibility.
# # Running this code will create a new SCHEMA or DATASET in BigQuery
# # Store results of this query in create_dataset_results
# 
# %%bigquery create_dataset_results
# CREATE SCHEMA IF NOT EXISTS challenge_two
# OPTIONS (
#   location="us",
#   default_table_expiration_days=14
# );

# Results of the CREATE SCHEMA (dataset) and CREATE OR REPLACE TABLE queries
create_dataset_results

# Run bq command to load data from a CSV file in a Google bucket to our new dataset / table
# Store results of query in load_data_results

!bq load --autodetect --source_format=CSV --skip_leading_rows=1 --field_delimiter=',' challenge_two.orig_data gs://labs.roitraining.com/data-to-ai-workshop/emergency_calls_response_times.csv

# Commented out IPython magic to ensure Python compatibility.
# # Show table from BigQuery
# # Store results in get_orig_data
# %%bigquery get_orig_data
# SELECT * FROM challenge_two.orig_data

# Show results from the load table
get_orig_data

"""# Step 2: Transform the data
# Transforming fields in preparation for ML model
# One-Hot encoding fields with STRING that matter to predicting response times
"""

# Commented out IPython magic to ensure Python compatibility.
# # Transform data
# # Modify the raw data elements in the following ways for preparation of ML model:
# # One-hot encoding STRING fields which will matter for predicting response times
# # One-hot encode call_type
# # One-hot encode weather_condition
# # One-hot encode day_of_week
# # One-hot encode traffic_level
# 
# %%bigquery transform_data
# CREATE OR REPLACE TABLE `challenge_two.transformed_data` AS (
#    SELECT
# #     -- Select all original columns, excluding those we are transforming to avoid duplication
#      * EXCEPT (
#        call_type, weather_condition, day_of_week, traffic_level
#      ),
# 
# #     -- Step 1: One-hot encode call_type
# #     -- Creates a new column for each category with a 1 or 0
#      CASE WHEN call_type = 'Police' THEN 1 ELSE 0 END AS call_type_police,
#      CASE WHEN call_type = 'Fire' THEN 1 ELSE 0 END AS call_type_fire,
#      CASE WHEN call_type = 'Rescue' THEN 1 ELSE 0 END AS call_type_rescue,
#      CASE WHEN call_type = 'Medical' THEN 1 ELSE 0 END AS call_type_medical,
# 
# #     -- Step 2: One-hot encode weather_condition
#       -- Creates a new column for each category with a 1 or 0
#      CASE WHEN weather_condition = 'Rainy' THEN 1 ELSE 0 END AS weather_condition_rainy,
#      CASE WHEN weather_condition = 'Windy' THEN 1 ELSE 0 END AS weather_condition_windy,
#      CASE WHEN weather_condition = 'Sunny' THEN 1 ELSE 0 END AS weather_condition_sunny,
#      CASE WHEN weather_condition = 'Snowy' THEN 1 ELSE 0 END AS weather_condition_snowy,
# 
# #     -- Step 3: One-hot encode day_of_week
# #     -- Creates a new column for each category with a 1 or 0
#      CASE WHEN day_of_week = 'Sunday' THEN 1 ELSE 0 END AS day_of_week_sunday,
#      CASE WHEN day_of_week = 'Monday' THEN 1 ELSE 0 END AS day_of_week_monday,
#      CASE WHEN day_of_week = 'Tuesday' THEN 1 ELSE 0 END AS day_of_week_tuesday,
#      CASE WHEN day_of_week = 'Wednesday' THEN 1 ELSE 0 END AS day_of_week_wednesday,
#      CASE WHEN day_of_week = 'Thursday' THEN 1 ELSE 0 END AS day_of_week_thursday,
#      CASE WHEN day_of_week = 'Friday' THEN 1 ELSE 0 END AS day_of_week_friday,
#      CASE WHEN day_of_week = 'Saturday' THEN 1 ELSE 0 END AS day_of_week_saturday,
# 
# #     -- Step 4: One-hot encode day_of_week
# #     -- Creates a new column for each category with a 1 or 0
#      CASE WHEN traffic_level = 'Low' THEN 1 ELSE 0 END AS traffic_level_low,
#      CASE WHEN traffic_level = 'Medium' THEN 1 ELSE 0 END AS traffic_level_medium,
#      CASE WHEN traffic_level = 'High' THEN 1 ELSE 0 END AS traffic_level_high
# 
# # Transform from the orig_data tabe in the challenge_two dataset
#    FROM
#      `challenge_two.orig_data`
#  );
#

# Commented out IPython magic to ensure Python compatibility.
# # Show table from BigQuery
# # Store results in get_transformed_data
# %%bigquery get_transformed_data
# SELECT * FROM challenge_two.transformed_data

# Show results from the load table
get_transformed_data

"""# Step 3: Create ML Model for predicting response times"""

# Commented out IPython magic to ensure Python compatibility.
# # Create the ML Model
# # Store results in create_model
# 
# %%bigquery create_model
# CREATE OR REPLACE MODEL `challenge_two.predict_response_times`
# OPTIONS (model_type='linear_reg',
# input_label_cols=['response_time']) AS
# SELECT * FROM challenge_two.transformed_data
# WHERE response_time IS NOT NULL AND call_timestamp BETWEEN '2023-01-01' AND '2023-11-30'

# Commented out IPython magic to ensure Python compatibility.
# # Evaluate the ML Model
# # Store results in evaluate_model
# 
# %%bigquery evaluate_model
# SELECT * FROM ML.EVALUATE (
#   MODEL challenge_two.predict_response_times
# );

# Show results from the evaulate model
evaluate_model

# Commented out IPython magic to ensure Python compatibility.
# # Perform predictions with our ML Model
# # Store results in predict_model
# 
# %%bigquery predict_model
# SELECT * FROM ML.PREDICT (
# MODEL`challenge_two.predict_response_times`,
# (SELECT * FROM challenge_two.transformed_data
# WHERE response_time IS NOT NULL AND call_timestamp BETWEEN '2023-12-01' AND '2023-12-31'))

# Show results from the predict model
predict_model
