# -*- coding: utf-8 -*-
"""Challenge_Five_Just_Update_Forecasts

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/embedded/projects/qwiklabs-gcp-03-d3c5d190e927/locations/us-central1/repositories/7b6d41cc-aa9b-4dc1-a7b8-45a7c5bd9695

Jupyter Notebook for Challenge Five to update weather alerts for large US airports
"""

# ==============================================================================
#                      SINGLE-BLOCK SCRIPT FOR VERTEX AI COLLAB
# ==============================================================================
# This script performs the following actions:
# 1. Installs necessary libraries and handles authentication.
# 2. Defines functions to get weather data and generate AI-powered alerts.
# 3. Reads airport data from a BigQuery table ('just_large_airports').
# 4. For each airport, fetches a weather forecast and uses Gemini to create an alert.
# 5. Creates a new BigQuery table ('large_airports_with_alerts') with the original
#    airport data plus the new forecast details and the Gemini alert.
# ==============================================================================

# --- 1. SETUP AND AUTHENTICATION ---
# Install required libraries silently
# !pip install --upgrade --quiet google-cloud-aiplatform google-cloud-bigquery pandas db-dtypes

# Authenticate and set up your project
# This command will generate a link for you to click and authenticate in your browser.
# !gcloud auth application-default login

import pandas as pd
import vertexai
from google.cloud import bigquery
from vertexai.generative_models import GenerativeModel, Part
from typing import Optional, List, Dict # Added these imports
import requests # Added this import since requests is used in get_extended_weather_forecast

# --- 2. CONFIGURATION - MODIFY THESE VALUES ---
PROJECT_ID = "qwiklabs-gcp-03-d3c5d190e927"  # <--- REPLACE WITH YOUR GOOGLE CLOUD PROJECT ID
LOCATION = "us-central1"        # <--- REPLACE WITH YOUR PREFERRED GCP REGION

BQ_DATASET = "challenge_five"
BQ_SOURCE_TABLE = "just_large_airports"
BQ_DESTINATION_TABLE = "large_airports_with_alerts" # Name for the new table

# --- 3. INITIALIZE CLIENTS ---
# Initialize Vertex AI SDK
vertexai.init(project=PROJECT_ID, location=LOCATION)

# Initialize BigQuery client
bq_client = bigquery.Client(project=PROJECT_ID)

# Initialize the Gemini Pro model
gemini_model = GenerativeModel("gemini-2.0-flash")
print("âœ… Initialization Complete: Vertex AI and BigQuery clients are ready.")


# --- 4. HELPER FUNCTIONS ---

# IMPORTANT: Replace this mock function with your actual implementation.
# This version returns sample data in the correct format for demonstration.
def get_extended_weather_forecast(lat: float, lon: float) -> Optional[List[Dict[str, str]]]:
   """
   Fetch the extended weather forecast from the U.S. National Weather Service (NWS) API
   based on a given latitude and longitude.


   Args:
       lat (float): Latitude of the location (e.g., 38.8977).
       lon (float): Longitude of the location (e.g., -77.0365).


   Returns:
       Optional[List[Dict[str, str]]]: A list of forecast dictionaries for each time period,
       each containing:
           - 'name': Name of the forecast period (e.g., "Today", "Tonight")
           - 'startTime': ISO timestamp for the start of the forecast period
           - 'temperature': Temperature value
           - 'temperatureUnit': Temperature unit (e.g., "F" or "C")
           - 'windSpeed': Wind speed description
           - 'windDirection': Wind direction (e.g., "NW")
           - 'shortForecast': Short summary (e.g., "Partly Sunny")
           - 'detailedForecast': Full text forecast


       Returns None if data is unavailable or an error occurs.
   """
   headers = {
       'User-Agent': 'MyWeatherApp (doug@roitraining.com)',  # Replace with your actual email
       'Accept': 'application/geo+json'
   }


   # Step 1: Get metadata to find forecast URL
   points_url = f"https://api.weather.gov/points/{lat},{lon}"
   response = requests.get(points_url, headers=headers)


   if response.status_code != 200:
       print(f"Error fetching data from points endpoint: {response.status_code}")
       return None


   points_data = response.json()
   forecast_url = points_data['properties'].get('forecast')
   if not forecast_url:
       print("Forecast URL not found in response.")
       return None


   # Step 2: Fetch the forecast data
   forecast_response = requests.get(forecast_url, headers=headers)
   if forecast_response.status_code != 200:
       print(f"Error fetching forecast: {forecast_response.status_code}")
       return None


   forecast_data = forecast_response.json()
   periods = forecast_data['properties'].get('periods', [])


   if not periods:
       print("No forecast periods found in response.")
       return None


   # Return the full extended forecast
   extended_forecast = []
   for period in periods:
       extended_forecast.append({
           'name': period['name'],
           'startTime': period['startTime'],
           'temperature': str(period['temperature']),
           'temperatureUnit': period['temperatureUnit'],
           'windSpeed': period['windSpeed'],
           'windDirection': period['windDirection'],
           'shortForecast': period['shortForecast'],
           'detailedForecast': period['detailedForecast']
       })


   return extended_forecast


def generate_airport_alert(forecast: dict) -> str:
    """
    Uses Gemini to generate a concise operational alert from forecast data.
    """
    if not forecast:
        return "No forecast data available to generate an alert."

    prompt = f"""
    You are an aviation operations specialist. Based on the following weather forecast for an airport, write a concise 1-2 sentence operational alert for pilots and ground crew.
    Focus on conditions that could impact flights, such as strong winds, gusts, low visibility, or significant precipitation. Do not repeat the input data; synthesize an alert.

    Forecast Period: {forecast.get('name')}
    Temperature: {forecast.get('temperature')} {forecast.get('temperatureUnit')}
    Wind: {forecast.get('windSpeed')} from the {forecast.get('windDirection')}
    Summary: {forecast.get('shortForecast')}
    Details: {forecast.get('detailedForecast')}

    Alert:
    """
    try:
        response = gemini_model.generate_content(prompt)
        alert = response.text.strip().replace('\n', ' ')
        return alert
    except Exception as e:
        print(f"Error calling Gemini API: {e}")
        return "Failed to generate alert."

print("âœ… Helper functions defined.")


# --- 5. MAIN PROCESSING LOGIC ---
print("\nðŸš€ Starting main processing logic...")

# 5.1. Read the airports from the source table into a pandas DataFrame
query = f"""
    SELECT *
    FROM `{PROJECT_ID}.{BQ_DATASET}.{BQ_SOURCE_TABLE}`
"""
print(f"Executing query:\n{query}")
airports_df = bq_client.query(query).to_dataframe()
print(f"Found {len(airports_df)} airports to process.")

processed_records = []

# 5.2. Iterate through each airport, get weather, generate alert, and store result
for index, airport in airports_df.iterrows():
    print(f"\n--- Processing {airport.get('name', 'N/A')} ({airport.get('ident', 'N/A')}) ---")

    # Get weather forecast using your function
    forecast_list = get_extended_weather_forecast(
        airport['latitude_deg'],
        airport['longitude_deg']
    )

    # Use only the first forecast period
    first_period_forecast = forecast_list[0] if forecast_list else None

    # Start building the new record with all original airport data
    new_record = airport.to_dict()

    if first_period_forecast:
        # Generate the Gemini alert
        print("Generating Gemini alert...")
        gemini_alert = generate_airport_alert(first_period_forecast)
        print(f"  > Gemini Alert: {gemini_alert}")

        # Add all new forecast and alert columns to the record
        new_record['forecast_name'] = first_period_forecast.get('name')
        new_record['forecast_startTime'] = pd.to_datetime(first_period_forecast.get('startTime'))
        new_record['forecast_temperature'] = first_period_forecast.get('temperature')
        new_record['forecast_temperatureUnit'] = first_period_forecast.get('temperatureUnit')
        new_record['forecast_windSpeed'] = first_period_forecast.get('windSpeed')
        new_record['forecast_windDirection'] = first_period_forecast.get('windDirection')
        new_record['forecast_short'] = first_period_forecast.get('shortForecast')
        new_record['forecast_detailed'] = first_period_forecast.get('detailedForecast')
        new_record['gemini_alert'] = gemini_alert
    else:
        print("  > No forecast data found. Appending null values.")
        # If no forecast, fill new columns with None to maintain table structure
        keys_to_null = ['forecast_name', 'forecast_startTime', 'forecast_temperature',
                        'forecast_temperatureUnit', 'forecast_windSpeed', 'forecast_windDirection',
                        'forecast_short', 'forecast_detailed', 'gemini_alert']
        for key in keys_to_null:
            new_record[key] = None
        new_record['gemini_alert'] = "No forecast data available."

    processed_records.append(new_record)

# 5.3. Create the final DataFrame from our list of processed records
results_df = pd.DataFrame(processed_records)

print("\n--- âœ… Processing Complete ---")
print("Sample of 5 enriched records:")
display(results_df.head())


# --- 6. WRITE RESULTS TO BIGQUERY ---
destination_table_id = f"{PROJECT_ID}.{BQ_DATASET}.{BQ_DESTINATION_TABLE}"

job_config = bigquery.LoadJobConfig(
    write_disposition="WRITE_TRUNCATE", # Overwrite the table if it already exists
)

print(f"\nWriting {len(results_df)} rows to BigQuery table: {destination_table_id}...")
job = bq_client.load_table_from_dataframe(
    results_df, destination_table_id, job_config=job_config
)

job.result()  # Wait for the job to complete

print(f"âœ… Successfully created and populated table '{destination_table_id}'.")

# --- 7. VERIFICATION ---
print("\n--- Verification: Querying first 5 rows from the new BigQuery table ---")
verification_query = f"SELECT ident, name, forecast_short, gemini_alert FROM `{destination_table_id}` LIMIT 5"
verification_df = bq_client.query(verification_query).to_dataframe()
display(verification_df)